# DFA算法, Trie树,AC自动机匹配敏感词

## **DFA匹配机制如下**

存储所有节点状态States: {state_0, state_1, state_2}<br>

存储所有字符集:Alphabet: {a, b}<br>

存储状态转移Transitions:<br>
state_0 --a--> state_1<br>
state_1 --b--> state_2<br>

初始状态start_state: state_0<br>

每个关键词终态 Accept state: state_2<br>

### 特征:

**1. 确定性:
DFA 的确定性意味着在任何给定状态下，对于任何输入符号，都有且只有一个确定的状态转移。这与非确定性有限自动机（NFA）不同，NFA在同一状态下对相同的输入符号可能有多个状态转移
**

**2. 状态有限:
DFA 由一个有限的状态集合组成，这些状态表示自动机在任何时刻所处的不同配置**

**3. 输入字母表
DFA 有一个有限的输入字母表，这些字母是DFA能够识别的符号集**

**4. 转移函数:
DFA 有一个转移函数，它定义了在任何给定状态下对每个输入符号的状态转移。这个转移函数是确定性的，意味着在任何状态下，针对每个输入符号，都有且只有一个下一个状态**

**5. 初始状态
DFA 有一个唯一的初始状态，这是自动机开始处理输入字符串时所处的状态**

**6. 接受状态:
DFA 有一个或多个接受状态（终止状态），当DFA处理完输入字符串并最终停在接受状态时，表示该输入字符串被接受**

**7. 拒绝状态:
如果在处理输入字符串时，DFA没有进入接受状态，则该输入字符串被拒绝**

## **Trie树匹配机制如下** (实现了基础tire树/分段式trie树)

         root
         /  
        c
        |
        a
      / | \
     a  t  b
    /    \  



### 特征:

**1. 每个节点表示字符串中的一个字符,从根节点到某个节点的路径表示字符串的一个前缀**

**2. Trie 的根节点通常是空的，不包含任何字符**

**3. 节点包含一个bool标志 isEnd，用于指示该节点是否是某个单词的结束**

**4. 插入操作 插入单词时，从根节点开始，根据单词的每个字符向下移动。如果路径不存在，则创建新的节点**

**5. 搜索操作 搜索单词时，从根节点开始，根据单词的每个字符向下移动。如果路径不存在或到达的节点没有 isEnd 标志，则单词不存在**

**6. 删除操作 删除单词时，从根节点开始，根据单词的每个字符向下移动。如果路径不存在或到达的节点没有 isEnd
标志，则单词不存在。如果单词的所有字符都在 Trie 中，删除最后一个字符的节点的 isEnd 标志**

**7.空间复杂度 可以通过共享前缀来节省空间**

**8.时间复杂度 插入和搜索操作的时间复杂度为 O(n)，其中 n 是单词的长度**

**9. 场景:自动补全,拼写检查,IP路由**

## **AC自动机匹配机制如下**

**1.构建Trie树,Trie树的每个节点表示一个字符，路径从根节点到某个节点表示一个前缀** 

**2.构建失败指针,当在Trie树中无法继续匹配时，通过失败指针跳转到另一个可能匹配的位置**

**3.每个节点可以存储一个或多个模式串，这些模式串表示从根节点到该节点所经过的字符形成的字符串**

**4.构建Trie树和失败指针的时间复杂度为O(n)，其中n是所有模式串的总长度,匹配过程的时间复杂度为O(m)，其中m是文本的长度。因此，AC自动机的整体时间复杂度为O(n + m)**